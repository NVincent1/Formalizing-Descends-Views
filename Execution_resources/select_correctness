
From Views Require Import utils.
From Views.Execution_resources Require Import Execution_resources.
From Views.Execution_resources Require Import lemmas.
From Views.Execution_resources Require Import correctness_lemmas.
Require Import PeanoNat.


Proposition select_correct :
  forall i e d m m' l r,
  count i (thread_set' e) m -> count i (thread_set' (select_range e l r d)) m' -> m' <= m
.
Proof.
  induction e;
  intros.
  - simpl in *. inversion H0. apply le_0_n.
  - simpl in *. inversion H0. apply le_0_n.
  - simpl in *. destruct d.
    + destruct (r <=? Warp_size).
      * simpl in *. clear H. induction (r - l).
        inversion H0. apply le_0_n.
        simpl in *. apply IHn in H0. apply H0.
      * simpl in *. inversion H0. apply le_0_n.
    + inversion H0. apply le_0_n.
    + inversion H0. apply le_0_n.
  - destruct shp as [p z]. destruct p as [x y]. destruct id as [p idz]. destruct p as [idx idy].
    destruct d.
      + destruct x.
        * simpl in *; destruct y,z; try (destruct y); try (destruct z); destruct (r <=? 0) eqn: E;
          try (apply leb_correct in E; inversion E; subst; simpl in *);
          inversion H0; apply le_0_n.
        * destruct x.
          ** simpl in *; destruct y,z; try (destruct y); try (destruct z); destruct (r <=? 0) eqn: E;
          try (apply leb_correct in E; inversion E; subst; simpl in *);
          inversion H0; apply le_0_n.
          ** simpl in *. destruct y,z.
            ++ destruct (r <=? S (S x)) eqn: E. simpl in H0.
            clear E. clear H. induction (r - l). inversion H0. apply le_0_n. apply IHn in H0. apply H0.
            inversion H0; apply le_0_n.
            ++ destruct z; destruct (r <=? S (S x)); simpl in H0;
            try (clear H; induction (r - l); try (inversion H0; apply le_0_n); apply IHn in H0; apply H0).
            ++ destruct y; destruct (r <=? S (S x)); simpl in H0;
            try (clear H; induction (r - l); try (inversion H0; apply le_0_n); apply IHn in H0; apply H0).
            ++ destruct y,z.
              -- simpl in *. destruct (r <=? S (S x)) eqn: E.
                *** apply leb_correct in E.
                assert (count i (zip (buildList (S (S x)) (fun i => (zip (buildList 1 (fun j => (buildList 1 (fun k => b i j k)))))))) m).
                rewrite <- block_ok_xyz. apply H. simpl in *.
                apply zip_buildlist_inclusion with (n := S (S x)) (f := fun i => b i 0 0 :: []) (m := m) in H0.
                apply H0. apply E. apply H1.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- simpl in *. destruct (r <=? S (S x)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S x)) (f := ((fun i : nat =>
                    (thread_set_1z 1 1 (S (S z)) (fun x : ThreadId_t => x :: [])
                    (fun _ j k : nat => b i j k) ++ []) ++ [])))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev with (l1 := b (S x) 0 (S z) :: b (S x) 0 z
                    :: (thread_set_1z (S (S x)) 1 z (fun x : ThreadId_t => x :: []) b ++ [])) in H.
                    destruct H as [m1 [m2 [H0 [H1 H2]]]]; subst.
                    apply cat_count_rev with (l1 := b x 0 (S z) :: b x 0 z
                    :: (thread_set_1z (S x) 1 z (fun x : ThreadId_t => x :: []) b ++ [])) in H1.
                    destruct H1 as [m3 [m4 [H1 [H2 H3]]]]; subst.
                    simpl. repeat (rewrite cat_empty in *).
                    apply cat_count with (l1 := b (S x) 0 (S z) :: b (S x) 0 z
                    :: ((thread_set_1z 1 1 z (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b (S x) j k)))).
                    rewrite block_ok_z in H0. rewrite block_ok_z. apply H0.
                    apply cat_count with (l1 := b x 0 (S z) :: b x 0 z
                    :: thread_set_1z 1 1 z (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b x j k)).
                    rewrite block_ok_z in H1. rewrite block_ok_z. apply H1.
                    clear H0. clear H1.
                    generalize dependent m4. induction x.
                    +++ intros. apply H2.
                    +++ intros. simpl in *.
                        apply cat_count_rev with (l1 := b x 0 (S z) :: b x 0 z
                        :: (thread_set_1z (S x) 1 z (fun x : ThreadId_t => x :: []) b ++ [])) in H2.
                        destruct H2 as [m5 [m6 [H2 [H3 H4]]]]; subst.
                        apply cat_count with (l1 := b x 0 (S z) :: b x 0 z
                        :: ((thread_set_1z 1 1 z (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b x j k) ++
                        []) ++ [])).
                        repeat (rewrite cat_empty in *).
                        rewrite block_ok_z in H2. rewrite block_ok_z. apply H2.
                        apply IHx. apply H3.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- simpl in *. destruct (r <=? S (S x)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S x)) (f := ((fun i : nat =>
                    (thread_set_2yz 1 (S (S y)) 1 (fun x : ThreadId_t => x :: [])
                    (fun _ j k : nat => b i j k) ++ []))))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev with (l1 := b (S x) (S y) 0 :: b (S x) y 0
                    :: thread_set_2yz (S (S x)) y 1 (fun x : ThreadId_t => x :: []) b) in H.
                    destruct H as [m1 [m2 [H0 [H1 H2]]]]; subst.
                    apply cat_count_rev with (l1 := b x (S y) 0 :: b x y 0
                    :: thread_set_2yz (S x) y 1 (fun x : ThreadId_t => x :: []) b) in H1.
                    destruct H1 as [m3 [m4 [H1 [H2 H3]]]]; subst.
                    simpl. repeat (rewrite cat_empty in *).
                    apply cat_count with (l1 := b (S x) (S y) 0 :: b (S x) y 0
                    :: thread_set_2yz 1 y 1 (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b (S x) j k)).
                    rewrite block_ok_yz in H0. rewrite block_ok_yz. apply H0.
                    apply cat_count with (l1 := b x (S y) 0 :: b x y 0
                    :: thread_set_2yz 1 y 1 (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b x j k)).
                    rewrite block_ok_yz in H1. rewrite block_ok_yz. apply H1.
                    clear H0. clear H1.
                    generalize dependent m4. induction x.
                    +++ intros. apply H2.
                    +++ intros. simpl in *.
                        apply cat_count_rev with (l1 := b x (S y) 0 :: b x y 0
                        :: thread_set_2yz (S x) y 1 (fun x : ThreadId_t => x :: []) b) in H2.
                        destruct H2 as [m5 [m6 [H2 [H3 H4]]]]; subst.
                        apply cat_count with (l1 := b x (S y) 0 :: b x y 0
                        :: (thread_set_2yz 1 y 1 (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b x j k) ++
                        [])).
                        repeat (rewrite cat_empty in *).
                        rewrite block_ok_yz in H2. rewrite block_ok_yz. apply H2.
                        apply IHx. apply H3.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- simpl in *. destruct (r <=? S (S x)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S x)) (f := ((fun i : nat =>
                    (thread_set_2yz 1 (S (S y)) (S (S z)) (fun x : ThreadId_t => x :: [])
                    (fun _ j k : nat => b i j k) ++ []))))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev with (l1 := b (S x) (S y) (S z) :: b (S x) (S y) z
                    :: (thread_set_1z (S (S x)) (S (S y)) z (fun x : ThreadId_t => x :: []) b ++
                    b (S x) y (S z) :: b (S x) y z
                    :: thread_set_1z (S (S x)) (S y) z (fun x : ThreadId_t => x :: []) b ++
                    thread_set_2yz (S (S x)) y (S (S z)) (fun x : ThreadId_t => x :: []) b)) in H.
                    destruct H as [m1 [m2 [H0 [H1 H']]]]; subst.
                    simpl.
                    apply cat_count with (l1 := b (S x) (S y) (S z) :: b (S x) (S y) z
                    :: ((thread_set_1z 1 (S (S y)) z (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b (S x) j k) ++
                    b (S x) y (S z) :: b (S x) y z
                    :: thread_set_1z 1 (S y) z (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b (S x) j k) ++
                    thread_set_2yz 1 y (S (S z)) (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b (S x) j k)) ++ [])).
                    repeat (rewrite cat_empty). repeat (rewrite block_ok_z in *).
                    repeat (rewrite block_ok_yz in *). apply H0.
                    clear H0.
                    apply cat_count_rev with (l1 := b x (S y) (S z) :: b x (S y) z
                    :: (thread_set_1z (S x) (S (S y)) z (fun x : ThreadId_t => x :: []) b ++
                    b x y (S z) :: b x y z
                    :: thread_set_1z (S x) (S y) z (fun x : ThreadId_t => x :: []) b ++
                    thread_set_2yz (S x) y (S (S z)) (fun x : ThreadId_t => x :: []) b)) in H1.
                    destruct H1 as [m3 [m4 [H0 [H1 H']]]]; subst.
                    apply cat_count with (l1 := b x (S y) (S z) :: b x (S y) z
                    :: ((thread_set_1z 1 (S (S y)) z (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b x j k) ++
                    b x y (S z) :: b x y z
                    :: thread_set_1z 1 (S y) z (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b x j k) ++
                    thread_set_2yz 1 y (S (S z)) (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b x j k)) ++ [])).
                    repeat (rewrite cat_empty). repeat (rewrite block_ok_z in *).
                    repeat (rewrite block_ok_yz in *). apply H0.
                    clear H0.
                    generalize dependent m4. induction x.
                    --- intros. apply H1.
                    --- simpl. intros.
                    apply cat_count_rev with (l1 := b x (S y) (S z) :: b x (S y) z
                    :: (thread_set_1z (S x) (S (S y)) z (fun x : ThreadId_t => x :: []) b ++
                    b x y (S z) :: b x y z
                    :: thread_set_1z (S x) (S y) z (fun x : ThreadId_t => x :: []) b ++
                    thread_set_2yz (S x) y (S (S z)) (fun x : ThreadId_t => x :: []) b))in H1.
                    destruct H1 as [m1' [m2' [H1 [H2 H3]]]]; subst.
                    apply cat_count with (l1 := b x (S y) (S z) :: b x (S y) z
                    :: ((thread_set_1z 1 (S (S y)) z (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b x j k) ++
                    b x y (S z) :: b x y z ::
                    thread_set_1z 1 (S y) z (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b x j k) ++
                    thread_set_2yz 1 y (S (S z)) (fun x0 : ThreadId_t => x0 :: []) (fun _ j k : nat => b x j k)) ++ [])).
                    repeat (rewrite cat_empty). repeat (rewrite block_ok_z in *).
                    repeat (rewrite block_ok_yz in *). apply H1.
                    clear H1. apply IHx. apply H2.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
      + destruct y.
        * simpl in *; destruct x,z; try (destruct x); try (destruct z); destruct (r <=? 0) eqn: E;
          try (apply leb_correct in E; inversion E; subst; simpl in *);
          inversion H0; apply le_0_n.
        * destruct y.
          ** simpl in *; destruct x,z; try (destruct x); try (destruct z); destruct (r <=? 0) eqn: E;
          try (apply leb_correct in E; inversion E; subst; simpl in *);
          inversion H0; apply le_0_n.
          ** simpl in *. destruct x,z.
            ++ destruct (r <=? S (S y)) eqn: E. simpl in H0.
            clear E. clear H. induction (r - l). inversion H0. apply le_0_n. apply IHn in H0. apply H0.
            inversion H0; apply le_0_n.
            ++ destruct z; destruct (r <=? S (S y)); simpl in H0;
            try (clear H; induction (r - l); try (inversion H0; apply le_0_n); apply IHn in H0; apply H0).
            ++ destruct x; destruct (r <=? S (S y)); simpl in H0;
            try (clear H; induction (r - l); try (inversion H0; apply le_0_n); apply IHn in H0; apply H0).
            ++ destruct x,z.
              -- simpl in *. destruct (r <=? S (S y)) eqn: E.
                *** apply leb_correct in E.
                repeat (rewrite cat_empty in *).
                assert (count i (zip (buildList (S (S y)) (fun j => (buildList 1 (fun k => b 0 j k))))) m).
                rewrite <- block_ok_yz. apply H. simpl in *.
                apply zip_buildlist_inclusion with (n := S (S y)) (f := fun i => b 0 i 0 :: []) (m := m) in H0.
                apply H0. apply E. apply H1.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- simpl in *. destruct (r <=? S (S y)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S y)) (f := ((fun j : nat =>
                    (thread_set_1z 1 1 (S (S z)) (fun x : ThreadId_t => x :: [])
                    (fun i _ k : nat => b i j k) ++ []) ++ [])))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    repeat (rewrite cat_empty in *).
                    apply cat_count_rev with (l1 := b 0 (S y) (S z) :: b 0 (S y) z
                    :: thread_set_1z 1 (S (S y)) z (fun x : ThreadId_t => x :: []) b) in H.
                    destruct H as [m1 [m2 [H0 [H1 H2]]]]; subst.
                    apply cat_count_rev with (l1 := b 0 y (S z) :: b 0 y z
                    :: thread_set_1z 1 (S y) z (fun x : ThreadId_t => x :: []) b) in H1.
                    destruct H1 as [m3 [m4 [H1 [H2 H3]]]]; subst.
                    simpl. repeat (rewrite cat_empty in *).
                    apply cat_count with (l1 := b 0 (S y) (S z) :: b 0 (S y) z
                    :: thread_set_1z 1 1 z (fun x : ThreadId_t => x :: []) (fun i0 _ k : nat => b i0 (S y) k)).
                    rewrite block_ok_z in H0. rewrite block_ok_z. apply H0.
                    apply cat_count with (l1 := b 0 y (S z) :: b 0 y z
                    :: thread_set_1z 1 1 z (fun x : ThreadId_t => x :: []) (fun i0 _ k : nat => b i0 y k)).
                    rewrite block_ok_z in H1. rewrite block_ok_z. apply H1.
                    clear H0. clear H1.
                    generalize dependent m4. induction y.
                    +++ intros. apply H2.
                    +++ intros. simpl in *.
                        apply cat_count_rev with (l1 := b 0 y (S z) :: b 0 y z
                        :: thread_set_1z 1 (S y) z (fun x : ThreadId_t => x :: []) b) in H2.
                        destruct H2 as [m5 [m6 [H2 [H3 H4]]]]; subst.
                        apply cat_count with (l1 := b 0 y (S z) :: b 0 y z
                        :: ((thread_set_1z 1 1 z (fun x : ThreadId_t => x :: []) (fun i0 _ k : nat => b i0 y k) ++
                        []) ++ [])).
                        repeat (rewrite cat_empty in *).
                        rewrite block_ok_z in H2. rewrite block_ok_z. apply H2.
                        apply IHy. apply H3.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- apply transpose_xy_block in H. simpl in *. destruct (r <=? S (S y)) eqn: E.
                *** simpl in *. apply leb_correct in E. simpl in H0.
                    apply zip_buildlist_inclusion with (n := S (S y)) (f := (fun j : nat =>
                    (thread_set_3xyz (S (S x)) 1 1 (fun x : ThreadId_t => x :: [])
                    (fun i _ k : nat => b i j k))))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev with (l1 := b (S x) (S y) 0 :: b x (S y) 0
                    :: thread_set_2xz x (S (S y)) 1 (fun x0 : ThreadId_t => x0 :: []) b) in H.
                    destruct H as [m1 [m2 [H0 [H1 H2]]]]; subst.
                    apply cat_count_rev with (l1 := b (S x) y 0 :: b x y 0
                    :: thread_set_2xz x (S y) 1 (fun x0 : ThreadId_t => x0 :: []) b) in H1.
                    destruct H1 as [m3 [m4 [H1 [H2 H3]]]]; subst.
                    simpl. repeat (rewrite cat_empty in *).
                    apply cat_count with (l1 := b (S x) (S y) 0 :: b x (S y) 0
                    :: thread_set_3xyz x 1 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 _ k : nat => b i0 (S y) k)).
                    rewrite block_ok_xz in H0. rewrite block_ok_xyz. apply H0.
                    apply cat_count with (l1 := b (S x) y 0 :: b x y 0
                    :: thread_set_3xyz x 1 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 _ k : nat => b i0 y k)).
                    rewrite block_ok_xz in H1. rewrite block_ok_xyz. apply H1.
                    clear H0. clear H1.
                    generalize dependent m4. induction y.
                    +++ intros. apply H2.
                    +++ intros. simpl in *.
                        apply cat_count_rev with (l1 := b (S x) y 0 :: b x y 0
                        :: thread_set_2xz x (S y) 1 (fun x0 : ThreadId_t => x0 :: []) b) in H2.
                        destruct H2 as [m5 [m6 [H2 [H3 H4]]]]; subst.
                        apply cat_count with (l1 := b (S x) y 0 :: b x y 0
                        :: thread_set_3xyz x 1 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 _ k : nat => b i0 y k)).
                        repeat (rewrite cat_empty in *).
                        rewrite block_ok_xz in H2. rewrite block_ok_xyz. apply H2.
                        apply IHy. apply H3.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- apply transpose_xy_block in H. simpl in *. destruct (r <=? S (S y)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S y)) (f := (fun j : nat =>
                    (thread_set_3xyz (S (S x)) 1 (S (S z)) (fun x : ThreadId_t => x :: [])
                    (fun i _ k : nat => b i j k))))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev with (l1 := b (S x) (S y) (S z) :: b (S x) (S y) z
                    :: (thread_set_1z (S (S x)) (S (S y)) z (fun x0 : ThreadId_t => x0 :: []) b ++
                    b x (S y) (S z) :: b x (S y) z
                    :: thread_set_1z (S x) (S (S y)) z (fun x0 : ThreadId_t => x0 :: []) b ++
                    thread_set_2xz x (S (S y)) (S (S z)) (fun x0 : ThreadId_t => x0 :: []) b)) in H.
                    destruct H as [m1 [m2 [H0 [H1 H']]]]; subst.
                    simpl.
                    apply cat_count with (l1 := b (S x) (S y) (S z) :: b (S x) (S y) z
                    :: ((thread_set_1z (S (S x)) 1 z (fun x0 : ThreadId_t => x0 :: []) (fun i0 _ k : nat => b i0 (S y) k) ++ []) ++
                    b x (S y) (S z) :: b x (S y) z
                    :: (thread_set_1z (S x) 1 z (fun x0 : ThreadId_t => x0 :: []) (fun i0 _ k : nat => b i0 (S y) k) ++ []) ++
                    thread_set_3xyz x 1 (S (S z)) (fun x0 : ThreadId_t => x0 :: []) (fun i0 _ k : nat => b i0 (S y) k))).
                    repeat (rewrite cat_empty).
                    apply cat_count_rev with (l1 := b (S x) (S y) (S z) :: b (S x) (S y) z
                    :: thread_set_1z (S (S x)) (S (S y)) z (fun x0 : ThreadId_t => x0 :: []) b) in H0.
                    destruct H0 as [m0 [m0' [H0 [H0' H']]]]; subst.
                    repeat (rewrite block_ok_z in *).
                    apply cat_count with (l1 := b (S x) (S y) (S z) :: b (S x) (S y) z
                    :: buildList z (fun k : nat => b (S x) (S y) k)).
                    apply H0. clear H0.
                    apply cat_count_rev with (l1 := b x (S y) (S z) :: b x (S y) z
                    :: buildList z (fun k : nat => b x (S y) k)) in H0'.
                    destruct H0' as [m00 [m00' [H0 [H0' H']]]]; subst.
                    apply cat_count with (l1 := b x (S y) (S z) :: b x (S y) z
                    :: buildList z (fun k : nat => b x (S y) k)).
                    apply H0.
                    clear H0. apply transpose_xy_block.
                    rewrite block_ok_yxz. rewrite block_ok_xz in H0'.
                    simpl. rewrite cat_empty. apply H0'.
                    clear H0.
                    apply cat_count_rev with (l1 := b (S x) y (S z) :: b (S x) y z
                    :: (thread_set_1z (S (S x)) (S y) z (fun x0 : ThreadId_t => x0 :: []) b ++
                    b x y (S z) :: b x y z
                    :: thread_set_1z (S x) (S y) z (fun x0 : ThreadId_t => x0 :: []) b ++
                    thread_set_2xz x (S y) (S (S z)) (fun x0 : ThreadId_t => x0 :: []) b)) in H1.
                    destruct H1 as [m3 [m4 [H0 [H1 H']]]]; subst.
                    apply cat_count with (l1 := b (S x) y (S z) :: b (S x) y z
                    :: ((thread_set_1z (S (S x)) 1 z (fun x0 : ThreadId_t => x0 :: []) (fun i0 _ k : nat => b i0 y k) ++ []) ++
                    b x y (S z) :: b x y z
                    :: (thread_set_1z (S x) 1 z (fun x0 : ThreadId_t => x0 :: []) (fun i0 _ k : nat => b i0 y k) ++ []) ++
                    thread_set_3xyz x 1 (S (S z)) (fun x0 : ThreadId_t => x0 :: []) (fun i0 _ k : nat => b i0 y k))).
                    repeat (rewrite cat_empty).
                    apply cat_count_rev with (l1 := b (S x) y (S z) :: b (S x) y z
                    :: thread_set_1z (S (S x)) (S y) z (fun x0 : ThreadId_t => x0 :: []) b) in H0.
                    destruct H0 as [m0 [m0' [H0 [H0' H']]]]; subst.
                    repeat (rewrite block_ok_z in *).
                    apply cat_count with (l1 := b (S x) y (S z) :: b (S x) y z
                    :: buildList z (fun k : nat => b (S x) y k)).
                    apply H0. clear H0.
                    apply cat_count_rev with (l1 := b x y (S z) :: b x y z
                    :: buildList z (fun k : nat => b x y k)) in H0'.
                    destruct H0' as [m00 [m00' [H0 [H0' H']]]]; subst.
                    apply cat_count with (l1 := b x y (S z) :: b x y z
                    :: buildList z (fun k : nat => b x y k)).
                    apply H0.
                    clear H0. apply transpose_xy_block.
                    rewrite block_ok_yxz. rewrite block_ok_xz in H0'.
                    simpl. rewrite cat_empty. apply H0'.
                    clear H0.
                    generalize dependent m4. induction y.
                    --- intros. apply H1.
                    --- simpl. intros.
                    apply cat_count_rev with (l1 := b (S x) y (S z) :: b (S x) y z
                    :: (thread_set_1z (S (S x)) (S y) z (fun x0 : ThreadId_t => x0 :: []) b ++
                    b x y (S z) :: b x y z
                    :: thread_set_1z (S x) (S y) z (fun x0 : ThreadId_t => x0 :: []) b ++
                    thread_set_2xz x (S y) (S (S z)) (fun x0 : ThreadId_t => x0 :: []) b)) in H1.
                    destruct H1 as [m1' [m2' [H1 [H2 H3]]]]; subst.
                    apply cat_count with (l1 := b (S x) y (S z) :: b (S x) y z
                    :: ((thread_set_1z (S (S x)) 1 z (fun x0 : ThreadId_t => x0 :: []) (fun i0 _ k : nat => b i0 y k) ++ []) ++
                    b x y (S z) :: b x y z
                    :: (thread_set_1z (S x) 1 z (fun x0 : ThreadId_t => x0 :: []) (fun i0 _ k : nat => b i0 y k) ++ []) ++
                    thread_set_3xyz x 1 (S (S z)) (fun x0 : ThreadId_t => x0 :: []) (fun i0 _ k : nat => b i0 y k))).
                    repeat (rewrite cat_empty).
                    apply cat_count_rev with (l1 := b (S x) y (S z) :: b (S x) y z
                    :: thread_set_1z (S (S x)) (S y) z (fun x0 : ThreadId_t => x0 :: []) b) in H1.
                    destruct H1 as [m0 [m0' [H0 [H0' H']]]]; subst.
                    repeat (rewrite block_ok_z in *).
                    apply cat_count with (l1 := b (S x) y (S z) :: b (S x) y z
                    :: buildList z (fun k : nat => b (S x) y k)).
                    apply H0. clear H0.
                    apply cat_count_rev with (l1 := b x y (S z) :: b x y z
                    :: buildList z (fun k : nat => b x y k)) in H0'.
                    destruct H0' as [m00 [m00' [H0 [H0' H']]]]; subst.
                    apply cat_count with (l1 := b x y (S z) :: b x y z
                    :: buildList z (fun k : nat => b x y k)).
                    apply H0.
                    clear H0. apply transpose_xy_block.
                    rewrite block_ok_yxz. rewrite block_ok_xz in H0'.
                    simpl. rewrite cat_empty. apply H0'.
                    clear H1.
                    apply IHy. apply H2.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
      + destruct z.
        * simpl in *; destruct x,y; try (destruct x); try (destruct y); destruct (r <=? 0) eqn: E;
          try (apply leb_correct in E; inversion E; subst; simpl in *);
          inversion H0; apply le_0_n.
        * destruct z.
          ** simpl in *; destruct x,y; try (destruct x); try (destruct y); destruct (r <=? 0) eqn: E;
          try (apply leb_correct in E; inversion E; subst; simpl in *);
          inversion H0; apply le_0_n.
          ** simpl in *. destruct x,y.
            ++ destruct (r <=? S (S z)) eqn: E. simpl in H0.
            clear E. clear H. induction (r - l). inversion H0. apply le_0_n. apply IHn in H0. apply H0.
            inversion H0; apply le_0_n.
            ++ destruct y; destruct (r <=? S (S z)); simpl in H0;
            try (clear H; induction (r - l); try (inversion H0; apply le_0_n); apply IHn in H0; apply H0).
            ++ destruct x; destruct (r <=? S (S z)); simpl in H0;
            try (clear H; induction (r - l); try (inversion H0; apply le_0_n); apply IHn in H0; apply H0).
            ++ destruct x,y.
              -- simpl in *. destruct (r <=? S (S z)) eqn: E.
                *** apply leb_correct in E.
                repeat (rewrite cat_empty in *).
                assert (count i (buildList (S (S z)) (fun k => b 0 0 k)) m).
                rewrite <- block_ok_z. apply H. simpl in *.
                apply zip_buildlist_inclusion with (n := S (S z)) (f := fun i => b 0 0 i :: []) (m := m) in H0.
                apply H0. apply E.
                clear H. clear E. clear H0. generalize dependent m. induction z. intros. apply H1.
                intros. inversion H1; subst. simpl.
                  apply cons_eq. apply IHz. apply H4.
                  apply cons_neq. apply IHz. apply H4. apply Hneq.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- apply transpose_xz_block in H. simpl in *. destruct (r <=? S (S z)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S z)) (f := (fun k : nat =>
                    (thread_set_2yz 1 (S (S y)) 1 (fun x : ThreadId_t => x :: [])
                    (fun i j _ : nat => b i j k) ++ [])))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    repeat (rewrite cat_empty in *).
                    apply cat_count_rev with (l1 := b 0 (S y) (S z) :: b 0 y (S z)
                    :: thread_set_1y 1 y (S (S z)) (fun x0 : ThreadId_t => x0 :: []) b) in H.
                    destruct H as [m1 [m2 [H0 [H1 H2]]]]; subst.
                    apply cat_count_rev with (l1 := b 0 (S y) z :: b 0 y z
                    :: thread_set_1y 1 y (S z) (fun x0 : ThreadId_t => x0 :: []) b) in H1.
                    destruct H1 as [m3 [m4 [H1 [H2 H3]]]]; subst.
                    simpl. repeat (rewrite cat_empty in *).
                    apply cat_count with (l1 := b 0 (S y) (S z) :: b 0 y (S z)
                    :: thread_set_2yz 1 y 1 (fun x : ThreadId_t => x :: []) (fun i0 j _ : nat => b i0 j (S z))).
                    rewrite block_ok_y in H0. rewrite block_ok_yz.
                    clear H1. clear H2.
                    generalize dependent m1. induction y.
                      intros. apply H0.
                      intros. inversion H0; subst. simpl.
                        apply cons_eq. apply IHy. apply H4.
                        apply cons_neq. apply IHy. apply H4. apply Hneq.
                    apply cat_count with (l1 := b 0 (S y) z :: b 0 y z
                    :: thread_set_2yz 1 y 1 (fun x : ThreadId_t => x :: []) (fun i0 j _ : nat => b i0 j z)).
                    rewrite block_ok_y in H1. rewrite block_ok_yz.
                    clear H0. clear H2.
                    generalize dependent m3. induction y.
                      intros. apply H1.
                      intros. inversion H1; subst. simpl.
                        apply cons_eq. apply IHy. apply H4.
                        apply cons_neq. apply IHy. apply H4. apply Hneq.
                    clear H0. clear H1.
                    generalize dependent m4. induction z.
                    +++ intros. apply H2.
                    +++ intros. simpl in *.
                        apply cat_count_rev with (l1 := b 0 (S y) z :: b 0 y z
                        :: (thread_set_1y 1 y (S z) (fun x0 : ThreadId_t => x0 :: []) b ++ [])) in H2.
                        destruct H2 as [m5 [m6 [H2 [H3 H4]]]]; subst.
                        apply cat_count with (l1 := b 0 (S y) z :: b 0 y z
                        :: (thread_set_2yz 1 y 1 (fun x : ThreadId_t => x :: []) (fun i0 j _ : nat => b i0 j z) ++
                        [])).
                        repeat (rewrite cat_empty in *).
                        rewrite block_ok_y in H2. rewrite block_ok_yz.
                        clear IHz. clear H3.
                        generalize dependent m5. induction y.
                          intros. apply H2.
                          intros. inversion H2; subst. simpl.
                            apply cons_eq. apply IHy. apply H4.
                            apply cons_neq. apply IHy. apply H4. apply Hneq.
                        apply IHz. apply H3.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- apply transpose_xz_block in H. simpl in *. destruct (r <=? S (S z)) eqn: E.
                *** simpl in *. apply leb_correct in E. simpl in H0.
                    apply zip_buildlist_inclusion with (n := S (S z)) (f := (fun k : nat =>
                    (thread_set_3xyz (S (S x)) 1 1 (fun x : ThreadId_t => x :: [])
                    (fun i j _ : nat => b i j k))))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev with (l1 := b (S x) 0 (S z) :: b x 0 (S z)
                    :: thread_set_2xy x 1 (S (S z)) (fun x0 : ThreadId_t => x0 :: []) b) in H.
                    destruct H as [m1 [m2 [H0 [H1 H2]]]]; subst.
                    apply cat_count_rev with (l1 := b (S x) 0 z :: b x 0 z
                    :: thread_set_2xy x 1 (S z) (fun x0 : ThreadId_t => x0 :: []) b) in H1.
                    destruct H1 as [m3 [m4 [H1 [H2 H3]]]]; subst.
                    simpl. repeat (rewrite cat_empty in *).
                    apply cat_count with (l1 := b (S x) 0 (S z) :: b x 0 (S z)
                    :: thread_set_3xyz x 1 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 j _ : nat => b i0 j (S z))).
                    rewrite block_ok_xy in H0. rewrite block_ok_xyz. apply H0.
                    apply cat_count with (l1 := b (S x) 0 z :: b x 0 z
                    :: thread_set_3xyz x 1 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 j _ : nat => b i0 j z)).
                    rewrite block_ok_xy in H1. rewrite block_ok_xyz. apply H1.
                    clear H0. clear H1.
                    generalize dependent m4. induction z.
                    +++ intros. apply H2.
                    +++ intros. simpl in *.
                        apply cat_count_rev with (l1 := b (S x) 0 z :: b x 0 z
                        :: thread_set_2xy x 1 (S z) (fun x0 : ThreadId_t => x0 :: []) b) in H2.
                        destruct H2 as [m5 [m6 [H2 [H3 H4]]]]; subst.
                        apply cat_count with (l1 := b (S x) 0 z :: b x 0 z
                        :: thread_set_3xyz x 1 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 j _ : nat => b i0 j z)).
                        repeat (rewrite cat_empty in *).
                        rewrite block_ok_xy in H2. rewrite block_ok_xyz. apply H2.
                        apply IHz. apply H3.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- apply transpose_xz_block in H. simpl in *. destruct (r <=? S (S z)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S z)) (f := (fun k : nat =>
                    (thread_set_3xyz (S (S x)) (S (S y)) 1 (fun x : ThreadId_t => x :: [])
                    (fun i j _ : nat => b i j k))))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev with (l1 := b (S x) (S y) (S z) :: b (S x) y (S z)
                    :: (thread_set_1y (S (S x)) y (S (S z)) (fun x0 : ThreadId_t => x0 :: []) b ++
                    b x (S y) (S z) :: b x y (S z)
                    :: thread_set_1y (S x) y (S (S z)) (fun x0 : ThreadId_t => x0 :: []) b ++
                    thread_set_2xy x (S (S y)) (S (S z)) (fun x0 : ThreadId_t => x0 :: []) b)) in H.
                    destruct H as [m1 [m2 [H0 [H1 H']]]]; subst.
                    simpl.
                    apply cat_count with (l1 := b (S x) (S y) (S z) :: b (S x) y (S z)
                    :: (thread_set_2yz (S (S x)) y 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 j _ : nat => b i0 j (S z)) ++
                    b x (S y) (S z) :: b x y (S z)
                    :: thread_set_2yz (S x) y 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 j _ : nat => b i0 j (S z)) ++
                    thread_set_3xyz x (S (S y)) 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 j _ : nat => b i0 j (S z)))).
                    repeat (rewrite cat_empty).
                    apply cat_count_rev with (l1 :=b (S x) (S y) (S z) :: b (S x) y (S z)
                    :: thread_set_1y (S (S x)) y (S (S z)) (fun x0 : ThreadId_t => x0 :: []) b) in H0.
                    destruct H0 as [m0 [m0' [H0 [H0' H']]]]; subst.
                    repeat (rewrite block_ok_y in *). repeat (rewrite block_ok_yz in *).
                    apply cat_count with (l1 := b (S x) (S y) (S z) :: b (S x) y (S z)
                    :: zip (buildList y (fun j : nat => buildList 1 (fun _ : nat => b (S x) j (S z))))).
                    clear H0'. clear H1.
                    assert (zip (buildList y (fun j : nat => buildList 1 (fun _ : nat => b (S x) j (S z))))
                        = buildList y (fun k : nat => b (S x) k (S z))). clear.
                      induction y. reflexivity. simpl. rewrite <- IHy. reflexivity.
                    rewrite H.
                    apply H0. clear H0.
                    apply cat_count_rev with (l1 := b x (S y) (S z) :: b x y (S z)
                    :: buildList y (fun k : nat => b x k (S z))) in H0'.
                    destruct H0' as [m00 [m00' [H0 [H0' H']]]]; subst.
                    apply cat_count with (l1 := b x (S y) (S z) :: b x y (S z)
                    :: zip (buildList y (fun j : nat => buildList 1 (fun _ : nat => b x j (S z))))).
                    assert (zip (buildList y (fun j : nat => buildList 1 (fun _ : nat => b x j (S z))))
                        = buildList y (fun k : nat => b x k (S z))). clear.
                      induction y. reflexivity. simpl. rewrite <- IHy. reflexivity.
                    rewrite H.
                    apply H0.
                    clear H0. apply transpose_xz_block.
                    rewrite block_ok_zxy. rewrite block_ok_xy in H0'.
                    simpl. rewrite cat_empty. apply H0'.
                    clear H0.
                    apply cat_count_rev with (l1 := b (S x) (S y) z :: b (S x) y z
                    :: (thread_set_1y (S (S x)) y (S z) (fun x0 : ThreadId_t => x0 :: []) b ++
                    b x (S y) z :: b x y z
                    :: thread_set_1y (S x) y (S z) (fun x0 : ThreadId_t => x0 :: []) b ++
                     thread_set_2xy x (S (S y)) (S z) (fun x0 : ThreadId_t => x0 :: []) b)) in H1.
                    destruct H1 as [m3 [m4 [H0 [H1 H']]]]; subst.
                    apply cat_count with (l1 := b (S x) (S y) z :: b (S x) y z
                    :: (thread_set_2yz (S (S x)) y 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 j _ : nat => b i0 j z) ++
                    b x (S y) z :: b x y z
                    :: thread_set_2yz (S x) y 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 j _ : nat => b i0 j z) ++
                    thread_set_3xyz x (S (S y)) 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 j _ : nat => b i0 j z))).
                    repeat (rewrite cat_empty).
                    apply cat_count_rev with (l1 := b (S x) (S y) z :: b (S x) y z
                    :: thread_set_1y (S (S x)) y (S z) (fun x0 : ThreadId_t => x0 :: []) b) in H0.
                    destruct H0 as [m0 [m0' [H0 [H0' H']]]]; subst.
                    repeat (rewrite block_ok_y in *).
                    repeat (rewrite block_ok_yz in *).
                    repeat (rewrite block_ok_xy in *).
                    apply cat_count with (l1 := b (S x) (S y) z :: b (S x) y z
                    :: zip (buildList y (fun j : nat => buildList 1 (fun _ : nat => b (S x) j z)))).
                    assert (zip (buildList y (fun j : nat => buildList 1 (fun _ : nat => b (S x) j z)))
                        = buildList y (fun k : nat => b (S x) k z)). clear.
                      induction y. reflexivity. simpl. rewrite <- IHy. reflexivity.
                    rewrite H.
                    apply H0. clear H0.
                    apply cat_count_rev with (l1 := b x (S y) z :: b x y z
                    :: buildList y (fun k : nat => b x k z)) in H0'.
                    destruct H0' as [m00 [m00' [H0 [H0' H']]]]; subst.
                    apply cat_count with (l1 := b x (S y) z :: b x y z
                    :: zip (buildList y (fun j : nat => buildList 1 (fun _ : nat => b x j z)))).
                    assert (zip (buildList y (fun j : nat => buildList 1 (fun _ : nat => b x j z)))
                        = buildList y (fun k : nat => b x k z)). clear.
                      induction y. reflexivity. simpl. rewrite <- IHy. reflexivity.
                    rewrite H.
                    apply H0. clear H0.
                    apply transpose_xz_block.
                    rewrite block_ok_zxy.
                    simpl. rewrite cat_empty. apply H0'.
                    clear H0.
                    generalize dependent m4. induction z.
                    --- intros. apply H1.
                    --- simpl. intros.
                    apply cat_count_rev with (l1 := b (S x) (S y) z :: b (S x) y z
                    :: (thread_set_1y (S (S x)) y (S z) (fun x0 : ThreadId_t => x0 :: []) b ++
                    b x (S y) z :: b x y z
                    :: thread_set_1y (S x) y (S z) (fun x0 : ThreadId_t => x0 :: []) b ++
                    thread_set_2xy x (S (S y)) (S z) (fun x0 : ThreadId_t => x0 :: []) b)) in H1.
                    destruct H1 as [m1' [m2' [H1 [H2 H3]]]]; subst.
                    apply cat_count with (l1 := b (S x) (S y) z :: b (S x) y z
                    :: (thread_set_2yz (S (S x)) y 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 j _ : nat => b i0 j z) ++
                    b x (S y) z :: b x y z
                    :: thread_set_2yz (S x) y 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 j _ : nat => b i0 j z) ++
                    thread_set_3xyz x (S (S y)) 1 (fun x0 : ThreadId_t => x0 :: []) (fun i0 j _ : nat => b i0 j z))).
                    repeat (rewrite cat_empty).
                    apply cat_count_rev with (l1 := b (S x) (S y) z :: b (S x) y z
                    :: thread_set_1y (S (S x)) y (S z) (fun x0 : ThreadId_t => x0 :: []) b) in H1.
                    destruct H1 as [m0 [m0' [H0 [H0' H']]]]; subst.
                    repeat (rewrite block_ok_y in *).
                    repeat (rewrite block_ok_yz in *).
                    repeat (rewrite block_ok_xy in *).
                    apply cat_count with (l1 := b (S x) (S y) z :: b (S x) y z
                    :: zip (buildList y (fun j : nat => buildList 1 (fun _ : nat => b (S x) j z)))).
                    assert (zip (buildList y (fun j : nat => buildList 1 (fun _ : nat => b (S x) j z)))
                        = buildList y (fun k : nat => b (S x) k z)). clear.
                      induction y. reflexivity. simpl. rewrite <- IHy. reflexivity.
                    rewrite H.
                    apply H0. clear H0.
                    apply cat_count_rev with (l1 := b x (S y) z :: b x y z
                    :: buildList y (fun k : nat => b x k z)) in H0'.
                    destruct H0' as [m00 [m00' [H0 [H0' H']]]]; subst.
                    apply cat_count with (l1 := b x (S y) z :: b x y z
                    :: zip (buildList y (fun j : nat => buildList 1 (fun _ : nat => b x j z)))).
                    assert (zip (buildList y (fun j : nat => buildList 1 (fun _ : nat => b x j z)))
                        = buildList y (fun k : nat => b x k z)). clear.
                      induction y. reflexivity. simpl. rewrite <- IHy. reflexivity.
                    rewrite H.
                    apply H0. clear H0.
                    apply transpose_xz_block.
                    rewrite block_ok_zxy.
                    simpl. rewrite cat_empty. apply H0'.
                    clear H1.
                    apply IHz. apply H2.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
  - destruct shp as [p z]. destruct p as [x y]. destruct shp' as [p z']. destruct p as [x' y'].
    destruct d.
      + destruct x.
        * simpl in *; destruct y,z; try (destruct y); try (destruct z); destruct (r <=? 0) eqn: E;
          try (apply leb_correct in E; inversion E; subst; simpl in *);
          inversion H0; apply le_0_n.
        * destruct x.
          ** simpl in *; destruct y,z; try (destruct y); try (destruct z); destruct (r <=? 0) eqn: E;
          try (apply leb_correct in E; inversion E; subst; simpl in *);
          inversion H0; apply le_0_n.
          ** simpl in *. destruct y,z.
            ++ destruct (r <=? S (S x)) eqn: E. simpl in H0.
            clear E. clear H. induction (r - l). inversion H0. apply le_0_n. apply IHn in H0. apply H0.
            inversion H0; apply le_0_n.
            ++ destruct z; destruct (r <=? S (S x)); simpl in H0;
            try (clear H; induction (r - l); try (inversion H0; apply le_0_n); apply IHn in H0; apply H0).
            ++ destruct y; destruct (r <=? S (S x)); simpl in H0;
            try (clear H; induction (r - l); try (inversion H0; apply le_0_n); apply IHn in H0; apply H0).
            ++ destruct y,z.
              -- simpl in *. destruct (r <=? S (S x)) eqn: E.
                *** apply leb_correct in E.
                assert (count i (zip (buildList (S (S x)) (fun i => zip (buildList 1 (fun j => zip (buildList 1 (fun k : nat =>
                  thread_set_3xyz x' y' z' (fun x0 : ThreadId_t => x0 :: []) (g i j k)))))))) m).
                rewrite <- grid_ok_xyz. apply H. simpl in *.
                apply zip_buildlist_inclusion with (n := S (S x)) (f := fun i => thread_set_3xyz x' y' z' (fun x : ThreadId_t => x :: []) (g i 0 0)) (m := m) in H0.
                apply H0. apply E. clear H0. clear E. clear H. simpl.
                repeat (rewrite cat_empty in H1).
                apply cat_count_rev in H1.
                destruct H1 as [m1 [m2 [H1 [H2 H']]]]; subst.
                apply cat_count_rev in H2.
                destruct H2 as [m3 [m4 [H2 [H3 H']]]]; subst.
                apply cat_count. apply H1.
                apply cat_count. apply H2.
                clear H1. clear H2. generalize dependent m4.
                induction x.
                  intros. apply H3.
                  intros. simpl in *. apply cat_count_rev in H3.
                  destruct H3 as [m5 [m6 [H1 [H2 H']]]]; subst.
                  apply cat_count. repeat (rewrite cat_empty in H1). apply H1. apply IHx. apply H2. 
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- simpl in *. destruct (r <=? S (S x)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S x)) (f := (fun i : nat =>
                    ((thread_set_1z 1 1 (S (S z)) (fun b : nat -> nat -> nat -> ThreadId_t =>
                    thread_set_3xyz x' y' z' (fun x : ThreadId_t => x :: []) b) (fun _ j k : nat => g i j k)) ++ []) ++ []))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev in H.
                    destruct H as [m1 [m2 [H0 [H1 H2]]]]; subst.
                    apply cat_count_rev in H1.
                    destruct H1 as [m3 [m4 [H1 [H2 H3]]]]; subst.
                    simpl. repeat (rewrite cat_empty in *).
                    apply cat_count.
                    rewrite grid_ok_z in H0. rewrite grid_ok_z. apply H0.
                    apply cat_count.
                    rewrite grid_ok_z in H1. rewrite grid_ok_z. apply H1.
                    clear H0. clear H1.
                    generalize dependent m4. induction x.
                    +++ intros. apply H2.
                    +++ intros. simpl in *.
                        apply cat_count_rev in H2.
                        destruct H2 as [m5 [m6 [H2 [H3 H4]]]]; subst.
                        apply cat_count.
                        repeat (rewrite cat_empty in *).
                        rewrite grid_ok_z in H2. rewrite grid_ok_z. apply H2.
                        apply IHx. apply H3.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- simpl in *. destruct (r <=? S (S x)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S x)) (f := (fun i : nat =>
                    ((thread_set_2yz 1 (S (S y)) 1 (fun b : nat -> nat -> nat -> ThreadId_t =>
                    thread_set_3xyz x' y' z' (fun x : ThreadId_t => x :: []) b) (fun _ j k : nat => g i j k)) ++ [])))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev in H.
                    destruct H as [m1 [m2 [H0 [H1 H2]]]]; subst.
                    apply cat_count_rev in H1.
                    destruct H1 as [m3 [m4 [H1 [H2 H3]]]]; subst.
                    simpl. repeat (rewrite cat_empty in *).
                    apply cat_count.
                    rewrite grid_ok_yz in H0. rewrite grid_ok_yz. apply H0.
                    apply cat_count.
                    rewrite grid_ok_yz in H1. rewrite grid_ok_yz. apply H1.
                    clear H0. clear H1.
                    generalize dependent m4. induction x.
                    +++ intros. apply H2.
                    +++ intros. simpl in *.
                        apply cat_count_rev in H2.
                        destruct H2 as [m5 [m6 [H2 [H3 H4]]]]; subst.
                        apply cat_count.
                        repeat (rewrite cat_empty in *).
                        rewrite grid_ok_yz in H2. rewrite grid_ok_yz. apply H2.
                        apply IHx. apply H3.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- simpl in *. destruct (r <=? S (S x)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S x)) (f := ((fun i : nat =>
                    (thread_set_2yz 1 (S (S y)) (S (S z)) (fun b : nat -> nat -> nat -> ThreadId_t =>
                    thread_set_3xyz x' y' z' (fun x : ThreadId_t => x :: []) b) (fun _ j k : nat => g i j k)) ++ [])))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev in H.
                    destruct H as [m1 [m2 [H0 [H1 H']]]]; subst.
                    simpl.
                    apply cat_count.
                    repeat (rewrite cat_empty). repeat (rewrite grid_ok_z in *).
                    repeat (rewrite grid_ok_yz in *). apply H0.
                    clear H0.
                    apply cat_count_rev in H1.
                    destruct H1 as [m3 [m4 [H0 [H1 H']]]]; subst.
                    apply cat_count.
                    repeat (rewrite cat_empty). repeat (rewrite grid_ok_z in *).
                    repeat (rewrite grid_ok_yz in *). apply H0.
                    clear H0.
                    generalize dependent m4. induction x.
                    --- intros. apply H1.
                    --- simpl. intros.
                    apply cat_count_rev in H1.
                    destruct H1 as [m1' [m2' [H1 [H2 H3]]]]; subst.
                    apply cat_count.
                    repeat (rewrite cat_empty). repeat (rewrite grid_ok_z in *).
                    repeat (rewrite grid_ok_yz in *). apply H1.
                    clear H1. apply IHx. apply H2.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
      + destruct y.
        * simpl in *; destruct x,z; try (destruct x); try (destruct z); destruct (r <=? 0) eqn: E;
          try (apply leb_correct in E; inversion E; subst; simpl in *);
          inversion H0; apply le_0_n.
        * destruct y.
          ** simpl in *; destruct x,z; try (destruct x); try (destruct z); destruct (r <=? 0) eqn: E;
          try (apply leb_correct in E; inversion E; subst; simpl in *);
          inversion H0; apply le_0_n.
          ** simpl in *. destruct x,z.
            ++ destruct (r <=? S (S y)) eqn: E. simpl in H0.
            clear E. clear H. induction (r - l). inversion H0. apply le_0_n. apply IHn in H0. apply H0.
            inversion H0; apply le_0_n.
            ++ destruct z; destruct (r <=? S (S y)); simpl in H0;
            try (clear H; induction (r - l); try (inversion H0; apply le_0_n); apply IHn in H0; apply H0).
            ++ destruct x; destruct (r <=? S (S y)); simpl in H0;
            try (clear H; induction (r - l); try (inversion H0; apply le_0_n); apply IHn in H0; apply H0).
            ++ destruct x,z.
              -- apply transpose_xy_grid in H. simpl in *. destruct (r <=? S (S y)) eqn: E.
                *** apply leb_correct in E.
                assert (count i (zip (buildList (S (S y)) (fun j => zip (buildList 1 (fun i => zip (buildList 1 (fun k : nat =>
                  thread_set_3xyz x' y' z' (fun x0 : ThreadId_t => x0 :: []) (g i j k)))))))) m).
                rewrite <- grid_ok_yxz. apply H. simpl in *.
                apply zip_buildlist_inclusion with (n := S (S y)) (f := fun j => thread_set_3xyz x' y' z' (fun x : ThreadId_t => x :: []) (g 0 j 0)) (m := m) in H0.
                apply H0. apply E. clear H0. clear E. clear H. simpl.
                repeat (rewrite cat_empty in H1).
                apply cat_count_rev in H1.
                destruct H1 as [m1 [m2 [H1 [H2 H']]]]; subst.
                apply cat_count_rev in H2.
                destruct H2 as [m3 [m4 [H2 [H3 H']]]]; subst.
                apply cat_count. apply H1.
                apply cat_count. apply H2.
                clear H1. clear H2. generalize dependent m4.
                induction y.
                  intros. apply H3.
                  intros. simpl in *. apply cat_count_rev in H3.
                  destruct H3 as [m5 [m6 [H1 [H2 H']]]]; subst.
                  apply cat_count. repeat (rewrite cat_empty in H1). apply H1. apply IHy. apply H2. 
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- simpl in *. destruct (r <=? S (S y)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    repeat (rewrite cat_empty in *).
                    apply zip_buildlist_inclusion with (n := S (S y)) (f := (fun j : nat =>
                    ((thread_set_1z 1 1 (S (S z)) (fun b : nat -> nat -> nat -> ThreadId_t =>
                    thread_set_3xyz x' y' z' (fun x : ThreadId_t => x :: []) b) (fun i _ k : nat => g i j k)) ++ []) ++ []))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev in H.
                    destruct H as [m1 [m2 [H0 [H1 H2]]]]; subst.
                    apply cat_count_rev in H1.
                    destruct H1 as [m3 [m4 [H1 [H2 H3]]]]; subst.
                    simpl. repeat (rewrite cat_empty in *).
                    apply cat_count.
                    rewrite grid_ok_z in H0. rewrite grid_ok_z. apply H0.
                    apply cat_count.
                    rewrite grid_ok_z in H1. rewrite grid_ok_z. apply H1.
                    clear H0. clear H1.
                    generalize dependent m4. induction y.
                    +++ intros. apply H2.
                    +++ intros. simpl in *.
                        apply cat_count_rev in H2.
                        destruct H2 as [m5 [m6 [H2 [H3 H4]]]]; subst.
                        apply cat_count.
                        repeat (rewrite cat_empty in *).
                        rewrite grid_ok_z in H2. rewrite grid_ok_z. apply H2.
                        apply IHy. apply H3.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- apply transpose_xy_grid in H. simpl in *. destruct (r <=? S (S y)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S y)) (f := (fun j : nat =>
                    ((thread_set_3xyz (S (S x)) 1 1 (fun b : nat -> nat -> nat -> ThreadId_t =>
                    thread_set_3xyz x' y' z' (fun x : ThreadId_t => x :: []) b) (fun i _ k : nat => g i j k)))))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev in H.
                    destruct H as [m1 [m2 [H0 [H1 H2]]]]; subst.
                    apply cat_count_rev in H1.
                    destruct H1 as [m3 [m4 [H1 [H2 H3]]]]; subst.
                    simpl. repeat (rewrite cat_empty in *).
                    apply cat_count.
                    rewrite grid_ok_xz in H0. rewrite grid_ok_xyz.
                    apply cat_count_rev in H0.
                    destruct H0 as [m1' [m2' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3' [m4' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'.
                    clear H1. clear H2. clear H0'.
                    generalize dependent m4'. induction x.
                      intros. apply H1'.
                      intros. simpl in *. apply cat_count_rev in H1'.
                      repeat (rewrite cat_empty in *).
                      destruct H1' as [m5' [m6' [H0' [H1' H2']]]]; subst.
                      apply cat_count. apply H0'.
                      apply IHx. apply H1'.
                    apply cat_count.
                    rewrite grid_ok_xz in H1. rewrite grid_ok_xyz.
                    apply cat_count_rev in H1.
                    destruct H1 as [m1' [m2' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3' [m4' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'.
                    clear H0. clear H2. clear H0'.
                    generalize dependent m4'. induction x.
                      intros. apply H1'.
                      intros. simpl in *. apply cat_count_rev in H1'.
                      repeat (rewrite cat_empty in *).
                      destruct H1' as [m5' [m6' [H0' [H1' H2']]]]; subst.
                      apply cat_count. apply H0'.
                      apply IHx. apply H1'.
                    clear H0. clear H1.
                    generalize dependent m4. induction y.
                    +++ intros. apply H2.
                    +++ intros. simpl in *.
                        apply cat_count_rev in H2.
                        destruct H2 as [m5 [m6 [H2 [H3 H4]]]]; subst.
                        apply cat_count.
                        repeat (rewrite cat_empty in *).
                        rewrite grid_ok_xz in H2. rewrite grid_ok_xyz.
                        apply cat_count_rev in H2.
                        destruct H2 as [m1' [m2' [H0' [H1' H2']]]]; subst.
                        apply cat_count. apply H0'. clear H0'.
                        apply cat_count_rev in H1'.
                        destruct H1' as [m3' [m4' [H0' [H1' H2']]]]; subst.
                        apply cat_count. apply H0'.
                        clear H0'. clear H3. clear IHy.
                        generalize dependent m4'. induction x.
                          intros. apply H1'.
                          intros. simpl in *. apply cat_count_rev in H1'.
                          repeat (rewrite cat_empty in *).
                          destruct H1' as [m5' [m6' [H0' [H1' H2']]]]; subst.
                          apply cat_count. apply H0'.
                          apply IHx. apply H1'.
                        apply IHy. apply H3.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- apply transpose_xy_grid in H. simpl in *. destruct (r <=? S (S y)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S y)) (f := ((fun j : nat =>
                    (thread_set_3xyz (S (S x)) 1 (S (S z)) (fun b : nat -> nat -> nat -> ThreadId_t =>
                    thread_set_3xyz x' y' z' (fun x : ThreadId_t => x :: []) b) (fun i _ k : nat => g i j k)))))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev in H.
                    destruct H as [m1 [m2 [H0 [H1 H']]]]; subst.
                    simpl.
                    apply cat_count.
                    repeat (rewrite cat_empty). clear H1. repeat (rewrite grid_ok_z in *).
                    repeat (rewrite grid_ok_xz in *). repeat (rewrite grid_ok_xyz in *).
                    apply cat_count_rev in H0.
                    destruct H0 as [m1' [m2' [H0' [H1' H']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3' [m4' [H0' [H1' H']]]]; subst.
                    apply cat_count. apply H0'.
                    clear H0'. generalize dependent m4'.
                    induction x.
                      intros. apply H1'.
                      intros. apply cat_count_rev in H1'.
                      destruct H1' as [m1'' [m2'' [H0'' [H1'' H']]]]; subst.
                      simpl in *. repeat (rewrite cat_empty in *).
                      apply cat_count. apply H0''. apply IHx. apply H1''.
                    apply cat_count_rev in H1.
                    clear H0.
                    destruct H1 as [m3 [m4 [H0 [H1 H']]]]; subst.
                    apply cat_count.
                    repeat (rewrite cat_empty). clear H1. repeat (rewrite grid_ok_z in *).
                    repeat (rewrite grid_ok_xz in *). repeat (rewrite grid_ok_xyz in *).
                    apply cat_count_rev in H0.
                    destruct H0 as [m1' [m2' [H0' [H1' H']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3' [m4' [H0' [H1' H']]]]; subst.
                    apply cat_count. apply H0'.
                    clear H0'. generalize dependent m4'.
                    induction x.
                      intros. apply H1'.
                      intros. apply cat_count_rev in H1'.
                      destruct H1' as [m1'' [m2'' [H0'' [H1'' H']]]]; subst.
                      simpl in *. repeat (rewrite cat_empty in *).
                      apply cat_count. apply H0''. apply IHx. apply H1''.
                    clear H0.
                    generalize dependent m4. induction y.
                    --- intros. apply H1.
                    --- simpl. intros.
                        apply cat_count_rev in H1.
                        destruct H1 as [m1' [m2' [H1 [H2 H3]]]]; subst.
                        apply cat_count.
                        repeat (rewrite cat_empty). clear H2. repeat (rewrite grid_ok_z in *).
                        repeat (rewrite grid_ok_xz in *). repeat (rewrite grid_ok_xyz in *).
                        apply cat_count_rev in H1.
                        destruct H1 as [m1'' [m2'' [H0' [H1' H']]]]; subst.
                        apply cat_count. apply H0'. clear H0'.
                        apply cat_count_rev in H1'.
                        destruct H1' as [m3' [m4' [H0' [H1' H']]]]; subst.
                        apply cat_count. apply H0'.
                        clear H0'. clear IHy. generalize dependent m4'.
                        induction x.
                          intros. apply H1'.
                          intros. apply cat_count_rev in H1'.
                          destruct H1' as [m1''' [m2''' [H0'' [H1'' H']]]]; subst.
                          simpl in *. repeat (rewrite cat_empty in *).
                          apply cat_count. apply H0''. apply IHx. apply H1''.
                        clear H1. apply IHy. apply H2.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
      + destruct z.
        * simpl in *; destruct x,y; try (destruct x); try (destruct y); destruct (r <=? 0) eqn: E;
          try (apply leb_correct in E; inversion E; subst; simpl in *);
          inversion H0; apply le_0_n.
        * destruct z.
          ** simpl in *; destruct x,y; try (destruct x); try (destruct y); destruct (r <=? 0) eqn: E;
          try (apply leb_correct in E; inversion E; subst; simpl in *);
          inversion H0; apply le_0_n.
          ** simpl in *. destruct x,y.
            ++ destruct (r <=? S (S z)) eqn: E. simpl in H0.
            clear E. clear H. induction (r - l). inversion H0. apply le_0_n. apply IHn in H0. apply H0.
            inversion H0; apply le_0_n.
            ++ destruct y; destruct (r <=? S (S z)); simpl in H0;
            try (clear H; induction (r - l); try (inversion H0; apply le_0_n); apply IHn in H0; apply H0).
            ++ destruct x; destruct (r <=? S (S z)); simpl in H0;
            try (clear H; induction (r - l); try (inversion H0; apply le_0_n); apply IHn in H0; apply H0).
            ++ destruct x,y.
              -- apply transpose_xz_grid in H. simpl in *. destruct (r <=? S (S z)) eqn: E.
                *** apply leb_correct in E.
                assert (count i (zip (buildList (S (S z)) (fun k => zip (buildList 1 (fun i => zip (buildList 1 (fun j : nat =>
                  thread_set_3xyz x' y' z' (fun x0 : ThreadId_t => x0 :: []) (g i j k)))))))) m).
                rewrite <- grid_ok_zxy. apply H. simpl in *.
                apply zip_buildlist_inclusion with (n := S (S z)) (f := fun k => thread_set_3xyz x' y' z' (fun x : ThreadId_t => x :: []) (g 0 0 k)) (m := m) in H0.
                apply H0. apply E. clear H0. clear E. clear H. simpl.
                repeat (rewrite cat_empty in H1).
                apply cat_count_rev in H1.
                destruct H1 as [m1 [m2 [H1 [H2 H']]]]; subst.
                apply cat_count_rev in H2.
                destruct H2 as [m3 [m4 [H2 [H3 H']]]]; subst.
                apply cat_count. apply H1.
                apply cat_count. apply H2.
                clear H1. clear H2. generalize dependent m4.
                induction z.
                  intros. apply H3.
                  intros. simpl in *. apply cat_count_rev in H3.
                  destruct H3 as [m5 [m6 [H1 [H2 H']]]]; subst.
                  apply cat_count. repeat (rewrite cat_empty in H1). apply H1. apply IHz. apply H2. 
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- apply transpose_xz_grid in H. simpl in *. destruct (r <=? S (S z)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    repeat (rewrite cat_empty in *).
                    apply zip_buildlist_inclusion with (n := S (S z)) (f := (fun k : nat =>
                    ((thread_set_2yz 1 (S (S y)) 1 (fun b : nat -> nat -> nat -> ThreadId_t =>
                    thread_set_3xyz x' y' z' (fun x : ThreadId_t => x :: []) b) (fun i j _ : nat => g i j k)) ++ [])))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev in H.
                    destruct H as [m1 [m2 [H0 [H1 H2]]]]; subst.
                    apply cat_count_rev in H1.
                    destruct H1 as [m3 [m4 [H1 [H2 H3]]]]; subst.
                    simpl. repeat (rewrite cat_empty in *).
                    apply cat_count.
                    clear H1. clear H2.
                    apply cat_count_rev in H0.
                    destruct H0 as [m1' [m2' [H0' [H1' H']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3' [m4' [H0' [H1' H']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    rewrite grid_ok_yz. rewrite grid_ok_y in H1'.
                    generalize dependent m4'. induction y.
                      intros. apply H1'.
                      intros. simpl in *. apply cat_count_rev in H1'.
                      destruct H1' as [m1'' [m2'' [H0'' [H1'' H']]]]; subst.
                      apply cat_count. rewrite cat_empty. apply H0''. apply IHy. apply H1''.
                    clear H0.
                    apply cat_count.
                    clear H2.
                    apply cat_count_rev in H1.
                    destruct H1 as [m1' [m2' [H0' [H1' H']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3' [m4' [H0' [H1' H']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    rewrite grid_ok_yz. rewrite grid_ok_y in H1'.
                    generalize dependent m4'. induction y.
                      intros. apply H1'.
                      intros. simpl in *. apply cat_count_rev in H1'.
                      destruct H1' as [m1'' [m2'' [H0'' [H1'' H']]]]; subst.
                      apply cat_count. rewrite cat_empty. apply H0''. apply IHy. apply H1''.
                    clear H1.
                    generalize dependent m4. induction z.
                    +++ intros. apply H2.
                    +++ intros. simpl in *.
                        apply cat_count_rev in H2.
                        destruct H2 as [m5 [m6 [H2 [H3 H4]]]]; subst.
                        apply cat_count.
                        repeat (rewrite cat_empty in *).
                        apply cat_count_rev in H2.
                        destruct H2 as [m1' [m2' [H0' [H1' H']]]]; subst.
                        apply cat_count. apply H0'. clear H0'.
                        apply cat_count_rev in H1'.
                        destruct H1' as [m3' [m4' [H0' [H1' H']]]]; subst.
                        apply cat_count. apply H0'. clear H0'.
                        rewrite grid_ok_yz. rewrite grid_ok_y in H1'.
                        generalize dependent m4'. clear H3. clear IHz. induction y.
                          intros. apply H1'.
                          intros. simpl in *. apply cat_count_rev in H1'.
                          destruct H1' as [m1'' [m2'' [H0'' [H1'' H']]]]; subst.
                          apply cat_count. rewrite cat_empty. apply H0''. apply IHy. apply H1''.
                        apply IHz. apply H3.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- apply transpose_xz_grid in H. simpl in *. destruct (r <=? S (S z)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S z)) (f := (fun k : nat =>
                    ((thread_set_3xyz (S (S x)) 1 1 (fun b : nat -> nat -> nat -> ThreadId_t =>
                    thread_set_3xyz x' y' z' (fun x : ThreadId_t => x :: []) b) (fun i j _ : nat => g i j k)))))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev in H.
                    destruct H as [m1 [m2 [H0 [H1 H2]]]]; subst.
                    apply cat_count_rev in H1.
                    destruct H1 as [m3 [m4 [H1 [H2 H3]]]]; subst.
                    simpl. repeat (rewrite cat_empty in *).
                    apply cat_count.
                    rewrite grid_ok_xy in H0. rewrite grid_ok_xyz.
                    apply cat_count_rev in H0.
                    destruct H0 as [m1' [m2' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3' [m4' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'.
                    clear H1. clear H2. clear H0'.
                    generalize dependent m4'. induction x.
                      intros. apply H1'.
                      intros. simpl in *. apply cat_count_rev in H1'.
                      repeat (rewrite cat_empty in *).
                      destruct H1' as [m5' [m6' [H0' [H1' H2']]]]; subst.
                      apply cat_count. apply H0'.
                      apply IHx. apply H1'.
                    apply cat_count.
                    rewrite grid_ok_xy in H1. rewrite grid_ok_xyz.
                    apply cat_count_rev in H1.
                    destruct H1 as [m1' [m2' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3' [m4' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'.
                    clear H0. clear H2. clear H0'.
                    generalize dependent m4'. induction x.
                      intros. apply H1'.
                      intros. simpl in *. apply cat_count_rev in H1'.
                      repeat (rewrite cat_empty in *).
                      destruct H1' as [m5' [m6' [H0' [H1' H2']]]]; subst.
                      apply cat_count. apply H0'.
                      apply IHx. apply H1'.
                    clear H0. clear H1.
                    generalize dependent m4. induction z.
                    +++ intros. apply H2.
                    +++ intros. simpl in *.
                        apply cat_count_rev in H2.
                        destruct H2 as [m5 [m6 [H2 [H3 H4]]]]; subst.
                        apply cat_count.
                        repeat (rewrite cat_empty in *).
                        rewrite grid_ok_xy in H2. rewrite grid_ok_xyz.
                        apply cat_count_rev in H2.
                        destruct H2 as [m1' [m2' [H0' [H1' H2']]]]; subst.
                        apply cat_count. apply H0'. clear H0'.
                        apply cat_count_rev in H1'.
                        destruct H1' as [m3' [m4' [H0' [H1' H2']]]]; subst.
                        apply cat_count. apply H0'.
                        clear H0'. clear H3. clear IHz.
                        generalize dependent m4'. induction x.
                          intros. apply H1'.
                          intros. simpl in *. apply cat_count_rev in H1'.
                          repeat (rewrite cat_empty in *).
                          destruct H1' as [m5' [m6' [H0' [H1' H2']]]]; subst.
                          apply cat_count. apply H0'.
                          apply IHx. apply H1'.
                        apply IHz. apply H3.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
              -- apply transpose_xz_grid in H. simpl in *. destruct (r <=? S (S z)) eqn: E.
                *** simpl in *. apply leb_correct in E.
                    apply zip_buildlist_inclusion with (n := S (S z)) (f := ((fun k : nat =>
                    (thread_set_3xyz (S (S x)) (S (S y)) 1 (fun b : nat -> nat -> nat -> ThreadId_t =>
                    thread_set_3xyz x' y' z' (fun x : ThreadId_t => x :: []) b) (fun i j _ : nat => g i j k)))))
                    (m := m) (i := i) (a := l) (m' := m') in H0.
                    apply H0. apply E.
                    clear E. clear H0.
                    apply cat_count_rev in H.
                    destruct H as [m1 [m2 [H0 [H1 H']]]]; subst.
                    simpl.
                    apply cat_count.
                    repeat (rewrite cat_empty). clear H1. repeat (rewrite grid_ok_y in *).
                    repeat (rewrite grid_ok_xy in *). repeat (rewrite grid_ok_xyz in *).
                    repeat (rewrite grid_ok_yz in *).
                    apply cat_count_rev in H0.
                    destruct H0 as [m1' [m2' [H0' [H1' H']]]]; subst.
                    apply cat_count.
                    clear H1'.
                    apply cat_count_rev in H0'.
                    destruct H0' as [m1'' [m2'' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3'' [m4'' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'.
                    clear H0'.
                    generalize dependent m4''. induction y.
                      intros. apply H1'.
                      intros. simpl in *. apply cat_count_rev in H1'.
                      repeat (rewrite cat_empty in *).
                      destruct H1' as [m5' [m6' [H0' [H1' H2']]]]; subst.
                      apply cat_count. apply H0'.
                      apply IHy. apply H1'.
                    clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3' [m4' [H0' [H1' H']]]]; subst.
                    apply cat_count. clear H1'.
                    apply cat_count_rev in H0'.
                    destruct H0' as [m1'' [m2'' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3'' [m4'' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'.
                    clear H0'.
                    generalize dependent m4''. induction y.
                      intros. apply H1'.
                      intros. simpl in *. apply cat_count_rev in H1'.
                      repeat (rewrite cat_empty in *).
                      destruct H1' as [m5' [m6' [H0' [H1' H2']]]]; subst.
                      apply cat_count. apply H0'.
                      apply IHy. apply H1'.
                    clear H0'. generalize dependent m4'.
                    induction x.
                      intros. apply H1'.
                      intros. simpl in *. apply cat_count_rev in H1'.
                      destruct H1' as [m1'' [m2'' [H0'' [H1'' H']]]]; subst.
                      simpl in *. repeat (rewrite cat_empty in *).
                      apply cat_count. clear H1''. clear IHx.
                        apply cat_count_rev in H0''.
                        destruct H0'' as [m3'' [m4'' [H0' [H1' H']]]]; subst.
                        apply cat_count. apply H0'. clear H0'.
                        apply cat_count_rev in H1'.
                        destruct H1' as [m5'' [m6'' [H0' [H1' H2']]]]; subst.
                        apply cat_count. apply H0'.
                        clear H0'.
                        generalize dependent m6''. induction y.
                          intros. apply H1'.
                          intros. simpl in *. repeat (rewrite cat_empty in *).
                          apply cat_count_rev in H1'.
                          destruct H1' as [m1''' [m2''' [H0' [H1' H2']]]]; subst.
                          apply cat_count. apply H0'. clear H0'.
                          apply IHy. apply H1'.
                      apply IHx. apply H1''.
                    apply cat_count_rev in H1.
                    clear H0.
                    destruct H1 as [m3 [m4 [H0 [H1 H']]]]; subst.
                    apply cat_count.
                    repeat (rewrite cat_empty). clear H1. repeat (rewrite grid_ok_y in *).
                    repeat (rewrite grid_ok_xy in *). repeat (rewrite grid_ok_xyz in *).
                    repeat (rewrite grid_ok_yz in *).
                    apply cat_count_rev in H0.
                    destruct H0 as [m1' [m2' [H0' [H1' H']]]]; subst.
                    apply cat_count.
                    clear H1'.
                    apply cat_count_rev in H0'.
                    destruct H0' as [m1'' [m2'' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3'' [m4'' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'.
                    clear H0'.
                    generalize dependent m4''. induction y.
                      intros. apply H1'.
                      intros. simpl in *. apply cat_count_rev in H1'.
                      repeat (rewrite cat_empty in *).
                      destruct H1' as [m5' [m6' [H0' [H1' H2']]]]; subst.
                      apply cat_count. apply H0'.
                      apply IHy. apply H1'.
                    clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3' [m4' [H0' [H1' H']]]]; subst.
                    apply cat_count. clear H1'.
                    apply cat_count_rev in H0'.
                    destruct H0' as [m1'' [m2'' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'. clear H0'.
                    apply cat_count_rev in H1'.
                    destruct H1' as [m3'' [m4'' [H0' [H1' H2']]]]; subst.
                    apply cat_count. apply H0'.
                    clear H0'.
                    generalize dependent m4''. induction y.
                      intros. apply H1'.
                      intros. simpl in *. apply cat_count_rev in H1'.
                      repeat (rewrite cat_empty in *).
                      destruct H1' as [m5' [m6' [H0' [H1' H2']]]]; subst.
                      apply cat_count. apply H0'.
                      apply IHy. apply H1'.
                    clear H0'. generalize dependent m4'.
                    induction x.
                      intros. apply H1'.
                      intros. simpl in *. apply cat_count_rev in H1'.
                      destruct H1' as [m1'' [m2'' [H0'' [H1'' H']]]]; subst.
                      simpl in *. repeat (rewrite cat_empty in *).
                      apply cat_count. clear H1''. clear IHx.
                        apply cat_count_rev in H0''.
                        destruct H0'' as [m3'' [m4'' [H0' [H1' H']]]]; subst.
                        apply cat_count. apply H0'. clear H0'.
                        apply cat_count_rev in H1'.
                        destruct H1' as [m5'' [m6'' [H0' [H1' H2']]]]; subst.
                        apply cat_count. apply H0'.
                        clear H0'.
                        generalize dependent m6''. induction y.
                          intros. apply H1'.
                          intros. simpl in *. repeat (rewrite cat_empty in *).
                          apply cat_count_rev in H1'.
                          destruct H1' as [m1''' [m2''' [H0' [H1' H2']]]]; subst.
                          apply cat_count. apply H0'. clear H0'.
                          apply IHy. apply H1'.
                      apply IHx. apply H1''.
                    clear H0.
                    generalize dependent m4. induction z.
                    --- intros. apply H1.
                    --- simpl. intros.
                        apply cat_count_rev in H1.
                        destruct H1 as [m1' [m2' [H1 [H2 H3]]]]; subst.
                        apply cat_count. clear H2.
                        repeat (rewrite cat_empty). repeat (rewrite grid_ok_y in *).
                        repeat (rewrite grid_ok_xy in *). repeat (rewrite grid_ok_xyz in *).
                        repeat (rewrite grid_ok_yz in *).
                        apply cat_count_rev in H1.
                        destruct H1 as [m1'' [m2'' [H0' [H1' H']]]]; subst.
                        apply cat_count.
                        clear H1'.
                        apply cat_count_rev in H0'.
                        destruct H0' as [m1''' [m2''' [H0' [H1' H2']]]]; subst.
                        apply cat_count. apply H0'. clear H0'.
                        apply cat_count_rev in H1'.
                        destruct H1' as [m3'' [m4'' [H0' [H1' H2']]]]; subst.
                        apply cat_count. apply H0'.
                        clear H0'.
                        generalize dependent m4''. clear IHz. induction y.
                          intros. apply H1'.
                          intros. simpl in *. apply cat_count_rev in H1'.
                          repeat (rewrite cat_empty in *).
                          destruct H1' as [m5' [m6' [H0' [H1' H2']]]]; subst.
                          apply cat_count. apply H0'.
                          apply IHy. apply H1'.
                        clear H0'.
                        apply cat_count_rev in H1'.
                        destruct H1' as [m3' [m4' [H0' [H1' H']]]]; subst.
                        apply cat_count. clear H1'.
                        apply cat_count_rev in H0'.
                        destruct H0' as [m1''' [m2'' [H0' [H1' H2']]]]; subst.
                        apply cat_count. apply H0'. clear H0'.
                        apply cat_count_rev in H1'.
                        destruct H1' as [m3''' [m4'' [H0' [H1' H2']]]]; subst.
                        apply cat_count. apply H0'.
                        clear H0'.
                        generalize dependent m4''. clear IHz. induction y.
                          intros. apply H1'.
                          intros. simpl in *. apply cat_count_rev in H1'.
                          repeat (rewrite cat_empty in *).
                          destruct H1' as [m5' [m6' [H0' [H1' H2']]]]; subst.
                          apply cat_count. apply H0'.
                          apply IHy. apply H1'.
                        clear H0'. clear IHz. generalize dependent m4'.
                        induction x.
                          intros. apply H1'.
                          intros. simpl in *. apply cat_count_rev in H1'.
                          destruct H1' as [m1''' [m2'' [H0'' [H1'' H']]]]; subst.
                          simpl in *. repeat (rewrite cat_empty in *).
                          apply cat_count. clear H1''. clear IHx.
                            apply cat_count_rev in H0''.
                            destruct H0'' as [m3'' [m4'' [H0' [H1' H']]]]; subst.
                            apply cat_count. apply H0'. clear H0'.
                            apply cat_count_rev in H1'.
                            destruct H1' as [m5'' [m6'' [H0' [H1' H2']]]]; subst.
                            apply cat_count. apply H0'.
                            clear H0'.
                            generalize dependent m6''. induction y.
                              intros. apply H1'.
                              intros. simpl in *. repeat (rewrite cat_empty in *).
                              apply cat_count_rev in H1'.
                              destruct H1' as [m1''' [m2''' [H0' [H1' H2']]]]; subst.
                              apply cat_count. apply H0'. clear H0'.
                              apply IHy. apply H1'.
                          apply IHx. apply H1''.
                        apply cat_count_rev in H1.
                        apply IHz. apply H2.
                *** simpl in H0. inversion H0; subst. apply le_0_n.
  - simpl in *. apply collection_ok_select with (n := n) (m := m) (m' := m') (l := l) (r := r) (d := d) in H.
    apply H. apply H0. apply H1.
  - inversion H0. apply le_0_n.
Qed.
